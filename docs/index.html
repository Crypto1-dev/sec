<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SEC Language Editor</title>
  <style>
    body {
      background: #f2f2f2;
      font-family: Consolas, monospace;
      padding: 20px;
      color: #333;
    }

    h1 {
      color: #222;
    }

    textarea {
      width: 100%;
      height: 300px;
      font-size: 14px;
      font-family: Consolas, monospace;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      resize: vertical;
    }

    #output {
      margin-top: 20px;
      padding: 10px;
      background: #e9ffe9;
      border: 1px solid #8fd88f;
      border-radius: 6px;
      white-space: pre-wrap;
      min-height: 100px;
    }

    #error-box {
      margin-top: 20px;
      display: none;
      background: #ffe6e6;
      color: #c00;
      padding: 10px;
      border: 1px solid red;
      border-radius: 6px;
      font-family: monospace;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      margin-top: 10px;
      cursor: pointer;
    }

    .sec-output {
      color: #111;
    }

    .sec-log {
      color: #117a11;
    }
  </style>
</head>
<body>
  <h1>SEC Language Editor</h1>
  <textarea id="code" placeholder="Write your SEC code here...">[main:: [say.x("Hello World!")] ]</textarea><br/>
  <button onclick="runSEC()">â–¶ Run SEC</button>

  <div id="output" class="sec-output"></div>
  <div id="error-box"></div>

  <script>
    function runSEC() {
      const code = document.getElementById("code").value;
      document.getElementById("output").innerText = "";
      document.getElementById("error-box").style.display = "none";
      try {
        parseSEC(code);
      } catch (e) {
        showSECError(e.message);
      }
    }

    function parseSEC(raw) {
      const lines = raw.split(/[\r\n]+/);
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line || line.startsWith("//")) continue;

        try {
          if (line.startsWith("[main::")) {
            parseMainBlock(line);
          } else if (line.startsWith("[shadow::")) {
            parseShadowBlock(line);
          } else if (line.startsWith("[js%%")) {
            executeJSBlock(line);
          } else if (line.startsWith("[shadow%%")) {
            executeShadowCode(line);
          } else {
            throw new Error(`Unrecognized block at line ${i + 1}: ${line}`);
          }
        } catch (err) {
          throw new Error(`Line ${i + 1}: ${err.message}`);
        }
      }
    }

    function parseMainBlock(line) {
      const commands = line.match(/\[(.*?)\]/g);
      if (!commands) throw new Error("No commands found in main block.");
      commands.forEach(cmd => {
        const clean = cmd.replace(/[\[\]]/g, "");
        if (clean.startsWith("say.x(")) {
          const msg = clean.match(/say\.x\("(.*)"\)/);
          if (msg) printOutput(msg[1]);
          else throw new Error("Invalid say.x syntax");
        } else if (clean.startsWith("num.mul(")) {
          const nums = clean.match(/num\.mul\("([^"]+)"\)/)[1].split(",");
          const result = Number(nums[0]) * Number(nums[1]);
          printOutput(result);
        } else if (clean.startsWith("num.add(")) {
          const nums = clean.match(/num\.add\("([^"]+)"\)/)[1].split(",");
          const result = Number(nums[0]) + Number(nums[1]);
          printOutput(result);
        } else if (clean.startsWith("num.div(")) {
          const nums = clean.match(/num\.div\("([^"]+)"\)/)[1].split(",");
          const result = Number(nums[0]) / Number(nums[1]);
          printOutput(result);
        } else if (clean.startsWith("num.sub(")) {
          const nums = clean.match(/num\.sub\("([^"]+)"\)/)[1].split(",");
          const result = Number(nums[0]) - Number(nums[1]);
          printOutput(result);
        }
      });
    }

    function parseShadowBlock(line) {
      printOutput("Shadow block started... (not fully implemented)");
    }

    function executeJSBlock(line) {
      const jsCode = line.substring(line.indexOf("%%") + 2, line.lastIndexOf("]")).trim();
      try {
        const result = eval(jsCode);
        if (result !== undefined) printOutput("[js%% result] " + result);
      } catch (e) {
        throw new Error("JavaScript error: " + e.message);
      }
    }

    function executeShadowCode(line) {
      const shadowCode = line.substring(line.indexOf("%%") + 2, line.lastIndexOf("]")).trim();
      if (shadowCode.includes("wait(")) {
        const ms = parseInt(shadowCode.match(/wait\((\d+)\)/)[1]);
        return new Promise(resolve => {
          setTimeout(() => {
            printOutput("[shadow%%] waited " + ms + "ms");
            resolve();
          }, ms);
        });
      } else {
        throw new Error("Unknown shadow code");
      }
    }

    function printOutput(text) {
      const output = document.getElementById("output");
      output.innerText += text + "\n";
    }

    function showSECError(message) {
      const errorBox = document.getElementById("error-box");
      errorBox.innerText = "ðŸš¨ SEC Error: " + message;
      errorBox.style.display = "block";
    }
  </script>
</body>
</html>
